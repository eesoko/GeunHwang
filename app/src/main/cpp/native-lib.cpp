#include <jni.h>
#include <string>
#include <vector>
#include <cstring>

// MATLAB Coder headers
#include "tmwtypes.h"

// ---- FEATURES ----
#include "features/feature_extractor_codegen.h"
#include "features/feature_extractor_codegen_emxAPI.h"
#include "features/feature_extractor_codegen_initialize.h"
#include "features/feature_extractor_codegen_terminate.h"

// ---- PREDICTION ----
// NOTE: predict_exercise_index.* must be generated by MATLAB Coder
#include "prediction/predict_exercise_index.h"
#include "prediction/predict_exercise_index_initialize.h"
#include "prediction/predict_exercise_index_terminate.h"

// ---- 라벨 매핑 (모델 ClassNames 순서와 반드시 일치시킬 것) ----
static const char* exercise_names[] = {
        "Dumbbell Curl",
        "Lunge",
        "Overhead Press",
        "Push Up",
        "Side Lateral Raise",
        "Squat"
};
static constexpr int kNumLabels = sizeof(exercise_names) / sizeof(exercise_names[0]);

// --------- Helper: Java 예외 발생 ---------
static void throwJava(JNIEnv* env, const char* msg) {
    jclass exClass = env->FindClass("java/lang/IllegalArgumentException");
    if (exClass) env->ThrowNew(exClass, msg);
}

// --------- Helper: Java Array<DoubleArray> -> emxArray_real_T* ---------
static bool toEmxArrayFrom2DDouble(JNIEnv* env,
                                   jobjectArray sensorData,
                                   emxArray_real_T** out) {
    if (!sensorData || !out) return false;

    jsize nRows = env->GetArrayLength(sensorData);
    if (nRows <= 0) return false;

    // 각 행은 double[6]이어야 함
    emxArray_real_T* A = emxCreate_real_T(nRows, 6);
    if (!A) return false;

    for (jsize i = 0; i < nRows; ++i) {
        jobject rowObj = env->GetObjectArrayElement(sensorData, i);
        if (!rowObj) { emxDestroyArray_real_T(A); return false; }

        jdoubleArray row = reinterpret_cast<jdoubleArray>(rowObj);
        jsize len = env->GetArrayLength(row);
        if (len != 6) {
            env->DeleteLocalRef(rowObj);
            emxDestroyArray_real_T(A);
            return false;
        }

        jboolean isCopy = JNI_FALSE;
        jdouble* elems = env->GetDoubleArrayElements(row, &isCopy);
        if (!elems) {
            env->DeleteLocalRef(rowObj);
            emxDestroyArray_real_T(A);
            return false;
        }

        // emxArray_real_T는 (r + nRows*c) 순서로 저장됨
        for (int c = 0; c < 6; ++c) {
            A->data[i + nRows * c] = elems[c];
        }

        env->ReleaseDoubleArrayElements(row, elems, 0);
        env->DeleteLocalRef(rowObj);
    }

    *out = A;
    return true;
}

// --------- JNI Entry ---------
extern "C"
JNIEXPORT jstring JNICALL
Java_com_example_geunhwang_presentation_ui_MainActivity_predictMotionNative(
        JNIEnv* env,
        jobject /* this */,
        jobjectArray sensorData,
        jdouble fs) {

    if (!sensorData) {
        throwJava(env, "sensorData is null");
        return nullptr;
    }
    if (fs <= 0.0) {
        throwJava(env, "fs must be positive");
        return nullptr;
    }

    // 초기화
    feature_extractor_codegen_initialize();
    predict_exercise_index_initialize();

    // Java 배열 -> emxArray 변환
    emxArray_real_T* raw = nullptr;
    if (!toEmxArrayFrom2DDouble(env, sensorData, &raw)) {
        throwJava(env, "Invalid sensorData shape; expected Array<double[6]>");
        predict_exercise_index_terminate();
        feature_extractor_codegen_terminate();
        return nullptr;
    }

    // 1) 특징 추출
    double features[32];
    std::memset(features, 0, sizeof(features));
    feature_extractor_codegen(raw, static_cast<double>(fs), features);

    emxDestroyArray_real_T(raw);

    // 2) 예측 (정수 인덱스, 1-based)
    int idx = predict_exercise_index(features);

    // 3) 라벨 매핑
    std::string result_str;
    if (idx >= 1 && idx <= kNumLabels) {
        result_str = exercise_names[idx - 1];
    } else {
        result_str = "Unknown";
    }

    // 4) JNI 문자열 반환
    jstring jres = env->NewStringUTF(result_str.c_str());

    // 종료
    predict_exercise_index_terminate();
    feature_extractor_codegen_terminate();

    return jres;
}
